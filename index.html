<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Worldwide Internet Nodes Dashboard</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #f8f9fa; }
        .dark-theme { background-color: #121212; color: #e0e0e0; }
        .dark-theme .card { background-color: #1e1e1e; color: #e0e0e0; border-color: #333; }
        .dark-theme #graph { background: #2d2d2d; border-color: #333; }
        #graph { border: 1px solid #dee2e6; height: 500px; background: white; }
        .node { stroke: #fff; stroke-width: 1.5px; }
        .dark-theme .node { stroke: #333; }
        .node.active { stroke: #007bff; stroke-width: 3px; }
        .link { stroke: #999; stroke-opacity: 0.6; }
        .dark-theme .link { stroke: #666; }
        .search-results { max-height: 200px; overflow-y: auto; }
        .loading { text-align: center; padding: 20px; color: #6c757d; }
        .search-result-item { cursor: pointer; padding: 8px 12px; border-bottom: 1px solid #eee; }
        .search-result-item:hover { background-color: #f8f9fa; }
        .dark-theme .search-result-item { border-bottom-color: #333; }
        .dark-theme .search-result-item:hover { background-color: #2a2a2a; }
        .no-results { padding: 8px 12px; color: #6c757d; font-style: italic; }
        #grokResponse { max-height: 200px; overflow-y: auto; white-space: pre-wrap; }
        .dark-theme #grokResponse { background-color: #2a2a2a; color: #e0e0e0; }
        .dark-theme .form-control { background-color: #333; color: #e0e0e0; border-color: #555; }
    </style>
</head>
<body>
    <div class="container-fluid py-4">
        <div class="row mb-4">
            <div class="col-12">
                <h1 class="text-center mb-3">Dynamic Worldwide Internet Nodes Dashboard</h1>
                <div class="text-end mb-3">
                    <button id="themeToggle" class="btn btn-outline-secondary">üåô Dark Mode</button>
                </div>
                <div class="input-group mb-3">
                    <input type="text" id="searchInput" class="form-control" placeholder="Search nodes by name, city, or type (e.g., 'London IXP')">
                    <button class="btn btn-primary" type="button" id="searchBtn">üîç Search</button>
                </div>
                <div id="searchResults" class="card mb-3 search-results d-none">
                    <div class="card-body">
                        <h6>Matching Nodes:</h6>
                        <ul id="resultsList" class="list-unstyled mb-0"></ul>
                    </div>
                </div>
            </div>
        </div>
        <div class="row">
            <div class="col-lg-8">
                <div class="card">
                    <div class="card-header">Interactive Node Graph</div>
                    <div id="graph">
                        <div class="loading">Loading graph data...</div>
                    </div>
                </div>
            </div>
            <div class="col-lg-4">
                <div class="card">
                    <div class="card-header">Selected Node Details</div>
                    <div id="nodeDetails" class="card-body">
                        <p class="text-muted">Click a node to view details.</p>
                    </div>
                </div>
                <div class="card mt-3">
                    <div class="card-header">Global Metrics</div>
                    <div class="card-body">
                        <ul class="list-unstyled">
                            <li>Total Nodes: <span id="totalNodes">Loading...</span></li>
                            <li>Active Peers: <span id="totalPeers">150</span></li>
                            <li>Avg Latency: <span id="avgLatency">45ms</span></li>
                        </ul>
                    </div>
                </div>
                <div class="card mt-3">
                    <div class="card-header">Ask Grok</div>
                    <div class="card-body">
                        <div id="apiKeySaved" class="text-success small d-none mb-2">API key saved.</div>
                        <div class="mb-2">
                            <label for="apiKeyInput" class="form-label small">xAI API Key:</label>
                            <input type="password" id="apiKeyInput" class="form-control" placeholder="Enter your xAI API key (get one at https://x.ai/api)">
                        </div>
                        <div class="mb-2">
                            <label for="grokQuestion" class="form-label small">Question:</label>
                            <textarea id="grokQuestion" class="form-control" rows="3" placeholder="Ask about the selected node or graph..."></textarea>
                        </div>
                        <button id="askGrokBtn" class="btn btn-info btn-sm mb-2" disabled>Ask Grok</button>
                        <div id="grokResponse" class="border rounded p-2 bg-light small d-none"></div>
                        <div id="grokLoading" class="text-muted small d-none">Thinking...</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        let nodesData = [];
        let linksData = [];
        let simulation, svg, nodeGroup, linkGroup, node, link;
        let searchTimeout;

        // Debounce utility for autocomplete
        function debounce(func, delay) {
            return function(...args) {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => func.apply(this, args), delay);
            };
        }

        // Grok API integration
        async function askGrok(question, apiKey) {
            const loading = document.getElementById('grokLoading');
            const responseDiv = document.getElementById('grokResponse');
            loading.classList.remove('d-none');
            responseDiv.classList.add('d-none');
            try {
                const res = await fetch('https://api.x.ai/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'grok-beta',
                        messages: [
                            { role: 'system', content: 'You are Grok, a highly intelligent, helpful AI assistant knowledgeable about internet infrastructure, peering, and IXPs.' },
                            { role: 'user', content: question }
                        ],
                        stream: false
                    })
                });
                if (!res.ok) {
                    throw new Error(`API error: ${res.status}`);
                }
                const data = await res.json();
                const answer = data.choices[0].message.content;
                responseDiv.textContent = answer;
                responseDiv.classList.remove('d-none');
            } catch (err) {
                responseDiv.innerHTML = `<div class="text-danger">Error: ${err.message}. Check your API key and try again.</div>`;
                responseDiv.classList.remove('d-none');
            } finally {
                loading.classList.add('d-none');
            }
        }

        async function loadData() {
            const graphDiv = document.getElementById('graph');
            graphDiv.innerHTML = '<div class="loading">Loading graph data...</div>';
            const proxyUrl = 'https://api.allorigins.win/raw?url=';
            const baseUrl = 'https://www.peeringdb.com/api/ix';
            let allIxs = [];
            let offset = 0;
            const limit = 250;
            const maxNodes = 500;
            try {
                while (true) {
                    const targetUrl = encodeURIComponent(`${baseUrl}?limit=${limit}&offset=${offset}`);
                    const res = await fetch(proxyUrl + targetUrl);
                    if (!res.ok) throw new Error(`Fetch failed: ${res.status}`);
                    const data = await res.json();
                    const ixs = data.data || [];
                    if (ixs.length === 0) break;
                    allIxs = allIxs.concat(ixs);
                    if (allIxs.length >= maxNodes) break;
                    offset += limit;
                }
                allIxs = allIxs.slice(0, maxNodes);
                nodesData = allIxs.map((ix, i) => ({
                    id: ix.id,
                    name: ix.name || 'Unnamed IXP',
                    city: ix.city || 'N/A',
                    country: ix.country || 'N/A',
                    x: Math.random() * 800,
                    y: Math.random() * 400,
                    type: 'IXP'
                }));
                // Generate sample links for visualization (in production, fetch real peering data)
                linksData = [];
                if (nodesData.length > 1) {
                    for (let i = 0; i < Math.min(20, nodesData.length); i++) {
                        const source = nodesData[i % nodesData.length];
                        const target = nodesData[(i + 1) % nodesData.length];
                        if (source.id !== target.id) {
                            linksData.push({ source: source.id, target: target.id });
                        }
                    }
                }
                document.getElementById('totalNodes').textContent = nodesData.length;
                graphDiv.innerHTML = '';
                if (simulation) {
                    updateGraph();
                } else {
                    initGraph();
                }
            } catch (err) {
                console.error('Error fetching data:', err);
                // Fallback: Load sample data
                nodesData = [
                    { id: 1, name: 'Sample IXP 1', city: 'London', country: 'GB', x: 200, y: 200, type: 'IXP' },
                    { id: 2, name: 'Sample IXP 2', city: 'New York', country: 'US', x: 600, y: 300, type: 'IXP' },
                    { id: 3, name: 'Sample IXP 3', city: 'Tokyo', country: 'JP', x: 400, y: 100, type: 'IXP' }
                ];
                linksData = [
                    { source: 1, target: 2 },
                    { source: 2, target: 3 },
                    { source: 3, target: 1 }
                ];
                document.getElementById('totalNodes').textContent = nodesData.length;
                graphDiv.innerHTML = '';
                if (simulation) {
                    updateGraph();
                } else {
                    initGraph();
                }
            }
        }

        function initGraph() {
            svg = d3.select("#graph").append("svg")
                .attr("width", "100%")
                .attr("height", "500")
                .attr("viewBox", "0 0 800 500")
                .attr("preserveAspectRatio", "xMidYMid meet");
            linkGroup = svg.append("g").attr("class", "links");
            nodeGroup = svg.append("g").attr("class", "nodes");

            simulation = d3.forceSimulation(nodesData)
                .force("link", d3.forceLink(linksData).id(d => d.id).distance(100))
                .force("charge", d3.forceManyBody().strength(-200))
                .force("center", d3.forceCenter(400, 250))
                .force("collide", d3.forceCollide().radius(10));

            updateElements();
            simulation.on("tick", ticked);
        }

        function updateGraph() {
            simulation.nodes(nodesData);
            simulation.force("link").links(linksData);
            simulation.alpha(1).restart();
            updateElements();
        }

        function updateElements() {
            link = linkGroup.selectAll("line")
                .data(linksData, d => `${Math.min(d.source.id, d.target.id)}-${Math.max(d.source.id, d.target.id)}`)
                .join("line")
                .attr("class", "link")
                .attr("stroke-width", 1);

            node = nodeGroup.selectAll("g")
                .data(nodesData, d => d.id)
                .join("g")
                .attr("class", "node")
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));

            node.selectAll("circle").data(d => [d]).join("circle")
                .attr("r", 5)
                .attr("fill", "#69b3a2");

            node.selectAll("title").data(d => [d]).join("title")
                .text(d => `${d.name} - ${d.city}, ${d.country}`);

            node.on("click", (event, d) => {
                d3.select(event.currentTarget).classed("active", true);
                setTimeout(() => d3.select(event.currentTarget).classed("active", false), 1000);
                updateNodeDetails(d);
            });
        }

        function updateNodeDetails(d) {
            document.getElementById('nodeDetails').innerHTML = `
                <h6>${d.name}</h6>
                <p>City: ${d.city}</p>
                <p>Country: ${d.country}</p>
                <p>Type: ${d.type}</p>
            `;
            // Prefill Grok question with node info
            const defaultQuestion = `Tell me more about ${d.name}, the IXP in ${d.city}, ${d.country}. What is its role in global internet peering?`;
            document.getElementById('grokQuestion').value = defaultQuestion;
        }

        function ticked() {
            link
                .attr("x1", d => d.source.x || 0)
                .attr("y1", d => d.source.y || 0)
                .attr("x2", d => d.target.x || 0)
                .attr("y2", d => d.target.y || 0);
            node
                .attr("transform", d => `translate(${d.x || 0}, ${d.y || 0})`);
        }

        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        // Theme toggle
        document.getElementById('themeToggle').addEventListener('click', () => {
            document.body.classList.toggle('dark-theme');
            const isDark = document.body.classList.contains('dark-theme');
            document.getElementById('themeToggle').textContent = isDark ? '‚òÄÔ∏è Light Mode' : 'üåô Dark Mode';
        });

        // Search functionality with autocomplete
        function performSearch(query = null) {
            const inputQuery = query || document.getElementById('searchInput').value.trim().toLowerCase();
            if (!inputQuery) {
                document.getElementById('searchResults').classList.add('d-none');
                return;
            }
            const results = nodesData.filter(n => 
                n.name.toLowerCase().includes(inputQuery) || 
                n.city.toLowerCase().includes(inputQuery) ||
                n.type.toLowerCase().includes(inputQuery)
            );
            const list = document.getElementById('resultsList');
            const resultsDiv = document.getElementById('searchResults');
            if (results.length === 0) {
                list.innerHTML = '<li class="no-results">No matching nodes found.</li>';
            } else {
                list.innerHTML = results.slice(0, 20).map(r => 
                    `<li class="search-result-item" onclick="selectNodeById(${r.id})">${r.name} - ${r.city}, ${r.country}</li>`
                ).join('');
            }
            resultsDiv.classList.remove('d-none');
        }

        const debouncedSearch = debounce(performSearch, 300);

        document.getElementById('searchBtn').addEventListener('click', () => performSearch());
        document.getElementById('searchInput').addEventListener('input', (e) => debouncedSearch(e.target.value));
        document.getElementById('searchInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                performSearch();
                document.getElementById('searchResults').classList.add('d-none');
                document.getElementById('searchInput').blur();
            }
        });

        function selectNodeById(id) {
            const nodeData = nodesData.find(n => n.id === id);
            if (nodeData) {
                updateNodeDetails(nodeData);
                // Highlight and simulate click on the node
                node.filter(d => d.id === id).dispatch("click");
            }
            document.getElementById('searchResults').classList.add('d-none');
            document.getElementById('searchInput').value = '';
        }

        // Hide search results when clicking outside
        document.addEventListener('click', (e) => {
            const searchInput = document.getElementById('searchInput');
            const searchResults = document.getElementById('searchResults');
            if (!searchInput.contains(e.target) && !searchResults.contains(e.target)) {
                searchResults.classList.add('d-none');
            }
        });

        // Grok API key handling
        const apiKeyInput = document.getElementById('apiKeyInput');
        const askGrokBtn = document.getElementById('askGrokBtn');
        const apiKeySaved = document.getElementById('apiKeySaved');
        const savedKey = localStorage.getItem('xaiApiKey');
        if (savedKey) {
            apiKeyInput.value = savedKey;
            askGrokBtn.disabled = false;
        }

        apiKeyInput.addEventListener('input', (e) => {
            const key = e.target.value.trim();
            if (key) {
                localStorage.setItem('xaiApiKey', key);
                apiKeySaved.classList.remove('d-none');
                setTimeout(() => apiKeySaved.classList.add('d-none'), 2000);
                askGrokBtn.disabled = false;
            } else {
                localStorage.removeItem('xaiApiKey');
                askGrokBtn.disabled = true;
            }
        });

        askGrokBtn.addEventListener('click', async () => {
            const question = document.getElementById('grokQuestion').value.trim();
            const apiKey = localStorage.getItem('xaiApiKey');
            if (!question || !apiKey) return;
            await askGrok(question, apiKey);
        });

        // Initialize
        loadData();
        // Refresh every 5 minutes for production (less aggressive)
        setInterval(loadData, 300000);
    </script>
</body>
</html>