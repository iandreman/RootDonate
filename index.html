<!DOCTYPE html>
<html lang="en" class="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Root Drops ‚Ä¢ Local Echoes (~500 m) ‚Äî Timeless Pins [2026 Fixed]</title>
  <meta name="description" content="Drop messages tied to your exact location. Visible only within ~500 m. Load GPS history to see your past footsteps."/>

  <style>
    :root {
      --bg: #000;
      --text: #e0e0e0;
      --accent: #00ff55;
      --accent-dark: #00cc44;
      --footprint: #3399ff;
      --danger: #ff3333;
      --info: #1e90ff;
      --export: #ff6600;
      --surface: #111;
      --surface-alt: #1a1a1a;
      --border: #333;
    }

    * { box-sizing: border-box; margin:0; padding:0; }
    html, body { height:100%; background:var(--bg); color:var(--text); font-family:system-ui, -apple-system, sans-serif; line-height:1.5; }
    .container { max-width:640px; margin:0 auto; padding:1.5rem; }

    h1 { text-align:center; color:var(--accent); margin:1rem 0 1.5rem; font-size:1.8rem; font-weight:700; text-shadow:0 0 20px rgba(0,255,85,0.15); }

    input, textarea { width:100%; padding:0.9rem 1rem; margin:0.6rem 0; background:#0d0d0d; border:1px solid var(--border); border-radius:12px; color:white; font-size:1rem; }
    input:focus, textarea:focus { outline:none; border-color:var(--accent); box-shadow:0 0 0 3px rgba(0,255,85,0.12); }
    textarea { min-height:120px; resize:vertical; }

    .buttons { display:flex; flex-wrap:wrap; gap:0.8rem; justify-content:center; margin:1.2rem 0; }
    button { padding:0.85rem 1.8rem; border:none; border-radius:12px; font-weight:600; cursor:pointer; transition:all 0.22s ease; min-width:140px; font-size:0.95rem; }
    button:hover { transform:translateY(-1px); }
    #dropBtn   { background:var(--accent-dark); color:#000; }
    #dropBtn:hover   { background:var(--accent); }
    #clearBtn  { background:#991111; color:white; }
    #clearBtn:hover  { background:var(--danger); }
    #reloadHistoryBtn { background:var(--info); color:white; }
    #exportJsonBtn    { background:var(--export); color:white; }

    #status { text-align:center; min-height:1.3em; font-size:0.92rem; margin:0.8rem 0; opacity:0; transition:opacity 0.4s; }
    #status.visible { opacity:1; }
    .success { color:#0f5; }
    .error   { color:#f66; }

    .section-title { color:var(--accent); font-size:1.15rem; font-weight:600; text-align:center; margin:2rem 0 0.8rem; opacity:0.9; }

    #dropZone { border:2px dashed var(--accent); border-radius:16px; padding:3rem 1rem; text-align:center; margin:1.5rem 0; cursor:pointer; background:#0a0a0a; }
    #dropZone.dragover { background:#111; border-color:var(--accent-dark); box-shadow:0 0 25px rgba(0,255,85,0.08); }
    #dropZone p { color:#888; margin:0.5rem 0; }

    .info-box { background:#181818; padding:1rem 1.2rem; border-radius:12px; margin:1rem 0; font-size:0.95rem; line-height:1.45; border:1px solid #222; }

    .stats { text-align:center; color:#888; font-size:0.9rem; margin:0.5rem 0 1.5rem; }

    .pin-list { margin-top:1.5rem; }
    .location-group { margin-bottom:2.2rem; border-radius:12px; overflow:hidden; }
    .location-header { background:var(--surface-alt); padding:0.9rem 1.2rem; font-weight:600; color:var(--accent); border:1px solid var(--border); border-bottom:none; }
    .pin { background:var(--surface); border:1px solid var(--border); border-top:none; padding:1.2rem 1.4rem; }
    .pin:not(:last-child) { border-bottom:1px solid #1e1e1e; }
    .pin-header { font-weight:700; margin-bottom:0.5rem; }
    .drop .pin-header { color:#88ffbb; }
    .footprint .pin-header { color:var(--footprint); }
    .pin-msg { white-space:pre-wrap; line-height:1.5; margin:0.6rem 0; font-size:0.97rem; }
    .pin-time { font-size:0.84rem; color:#777; text-align:right; margin-top:0.6rem; }

    .zero-history { background:#1a1a00; border:1px solid #664400; border-radius:12px; padding:1.5rem; margin:2rem 0; color:#ffcc66; text-align:center; line-height:1.6; }

    @media (max-width:500px) { .container { padding:1rem; } h1 { font-size:1.6rem; } button { min-width:120px; padding:0.8rem 1.4rem; } }
  </style>
</head>
<body>

  <div class="container">
    <h1>Root Drops ‚Ä¢ Local Echoes (~500 m) [2026 Fixed]</h1>

    <div class="info-box" id="locationInfo">Waiting for GPS fix‚Ä¶ (10‚Äì120s first time, go outside if slow)</div>

    <div class="section-title">Leave a Message (Visible ~500 m)</div>
    <input type="text" id="name" placeholder="Name / @handle" value="@iandreme" />
    <textarea id="msg" placeholder="Your shout, memory, warning‚Ä¶"></textarea>

    <div class="buttons">
      <button id="dropBtn">Drop Message</button>
      <button id="clearBtn">Clear Drops (~500 m)</button>
    </div>

    <div class="section-title">Load Your Footprints (Timeline.json)</div>
    <div id="dropZone">
      <p>Drag & drop Timeline.json here<br>or tap to choose file</p>
      <input type="file" id="fileInput" accept=".json" hidden>
    </div>

    <div class="buttons" style="margin-top:0.4rem;">
      <button id="reloadHistoryBtn">‚Üª Reopen Previous Timeline</button>
      <button id="exportJsonBtn">‚Üì Export Nearby Echoes (JSON)</button>
    </div>

    <div id="status"></div>

    <div id="historyStats" class="stats"></div>

    <div class="section-title">Nearby Echoes & Footprints (~500 m)</div>
    <div class="pin-list" id="pinList"></div>
  </div>

  <script>
    // Config
    const STORAGE_KEY       = 'root-donate-drops-v2';
    const COORD_PRECISION   = 6;
    const MATCH_TOLERANCE   = 0.0045;

    let userLat = null, userLng = null;
    let timelinePoints = [];

    // Helpers
    const round = n => Number(n.toFixed(COORD_PRECISION));
    const coordsMatch = (a,b,c,d) => Math.abs(a - c) <= MATCH_TOLERANCE && Math.abs(b - d) <= MATCH_TOLERANCE;

    function showStatus(msg, type = '') {
      const el = document.getElementById('status');
      el.textContent = msg;
      el.className = type ? `visible ${type}` : 'visible';
      setTimeout(() => el.className = '', 12000);
    }

    function updateLocInfo() {
      const el = document.getElementById('locationInfo');
      if (userLat == null) {
        el.textContent = 'Waiting for GPS fix‚Ä¶ (10‚Äì120s first time, go outside if slow)';
        el.style.color = '#777';
      } else {
        el.innerHTML = `üìç ${userLat.toFixed(6)}, ${userLng.toFixed(6)} <small>(~500 m radius)</small>`;
        el.style.color = 'var(--accent)';
      }
    }

    function updateHistoryStats() {
      const el = document.getElementById('historyStats');
      if (timelinePoints.length === 0) return;
      const nearby = timelinePoints.filter(p => userLat && coordsMatch(p.lat, p.lng, userLat, userLng)).length;
      el.innerHTML = `Loaded <strong>${timelinePoints.length}</strong> history pins total ‚Ä¢ ${nearby} nearby`;
    }

    // ‚îÄ‚îÄ‚îÄ FIXED PARSER FOR 2026 ON-DEVICE Timeline.json ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function parseTimeline(json) {
      const pts = [];
      console.log('JSON root keys:', Object.keys(json || {}));

      const cleanAndParse = (str) => {
        if (typeof str !== 'string') return null;
        const cleaned = str.replace(/¬∞/g, '').replace(/[^0-9.,-]/g, '').trim();
        if (!cleaned.includes(',')) return null;
        const parts = cleaned.split(',').map(s => s.trim());
        if (parts.length < 2) return null;
        const lat = parseFloat(parts[0]);
        const lng = parseFloat(parts[1]);
        return (!isNaN(lat) && !isNaN(lng)) ? {lat, lng} : null;
      };

      const extractCoord = (obj) => {
        let lat, lng, acc = '?', ts = obj.startTime || obj.endTime || obj.timestamp || '';

        // Target placeLocation in topCandidate (common in 2026 exports)
        let locStr = '';
        if (obj.topCandidate) {
          locStr = obj.topCandidate.placeLocation || obj.topCandidate.latLng || '';
        }
        if (obj.visit && obj.visit.topCandidate) {
          locStr = obj.visit.topCandidate.placeLocation || obj.visit.topCandidate.latLng || locStr;
        }
        if (obj.placeVisit && obj.placeVisit.topCandidate) {
          locStr = obj.placeVisit.topCandidate.placeLocation || obj.placeVisit.topCandidate.latLng || locStr;
        }
        if (!locStr) locStr = obj.placeLocation || obj.latLng || '';

        if (locStr) {
          const coord = cleanAndParse(locStr);
          if (coord) {
            lat = coord.lat;
            lng = coord.lng;
            console.log('Found pin:', lat.toFixed(6), lng.toFixed(6), 'from:', locStr);
          }
        }

        // Rare E7
        if (!lat && obj.latitudeE7 && obj.longitudeE7) {
          lat = obj.latitudeE7 / 1e7;
          lng = obj.longitudeE7 / 1e7;
          acc = obj.accuracyMeters || '?';
        }

        if (lat && lng) {
          return { lat, lng, accuracy: acc, timestamp: ts ? new Date(ts).toISOString() : new Date().toISOString() };
        }
        return null;
      };

      // Main loop: semanticSegments
      if (json?.semanticSegments?.length) {
        console.log(`Found ${json.semanticSegments.length} semanticSegments`);
        json.semanticSegments.forEach(s => {
          // Visit / placeVisit
          if (s.visit || s.placeVisit) {
            const target = s.visit || s.placeVisit;
            const coord = extractCoord(target);
            if (coord) pts.push({ type: 'history', ...coord });
          }
          // Frequent places
          if (s.userLocationProfile?.frequentPlaces?.length) {
            s.userLocationProfile.frequentPlaces.forEach(place => {
              const coord = extractCoord(place);
              if (coord) pts.push({ type: 'history', ...coord });
            });
          }
          // Direct in segment
          const coord = extractCoord(s);
          if (coord) pts.push({ type: 'history', ...coord });
        });
      }

      // Deep fallback scan
      function deepSearch(o) {
        if (typeof o !== 'object' || o === null) return;
        const coord = extractCoord(o);
        if (coord) pts.push({ type: 'history', ...coord });
        Object.values(o).forEach(deepSearch);
      }
      deepSearch(json);

      // Dedupe & sort (newest first)
      const unique = [...new Map(pts.map(p => [`${round(p.lat)},${round(p.lng)}`, p])).values()];
      unique.sort((a,b) => new Date(b.timestamp) - new Date(a.timestamp));
      console.log(`Parsed ${unique.length} GPS pins total`);
      return unique;
    }

    // ‚îÄ‚îÄ‚îÄ File Loading ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    async function loadFile(src) {
      let file;
      try { file = src.kind === 'file' ? await src.getFile() : src; } catch {
        showStatus('File access denied', 'error'); return false;
      }
      if (!file.name?.toLowerCase().endsWith('.json')) {
        showStatus('Select a .json file', 'error'); return false;
      }
      try {
        const text = await file.text();
        const data = JSON.parse(text);
        timelinePoints = parseTimeline(data);

        if (timelinePoints.length === 0) {
          showStatus('0 pins ‚Äì check F12 Console', 'error');
          document.getElementById('pinList').insertAdjacentHTML('afterbegin', `
            <div class="zero-history">
              <strong>No GPS pins detected</strong><br><br>
              ‚Ä¢ Press F12 ‚Üí Console tab now ‚Äì look for "Found pin:" or "Parsed X GPS pins"<br>
              ‚Ä¢ If console says "Found semanticSegments" but 0 pins ‚Üí export may have no coords (common issue)<br>
              ‚Ä¢ Search file for "," or "¬∞" (in text editor) ‚Äì paste line with coords here if found<br>
              ‚Ä¢ Drop manual messages ‚Äì they show as pins too!
            </div>
          `);
        } else {
          showStatus(`Loaded ${timelinePoints.length} GPS pins ‚úì`, 'success');
        }

        updateHistoryStats();
        renderAll();
        document.getElementById('pinList').scrollIntoView({ behavior: 'smooth' });
        return true;
      } catch (err) {
        showStatus('Invalid JSON', 'error');
        console.error(err);
        return false;
      }
    }

    // ‚îÄ‚îÄ‚îÄ Rest of your code (addDrop, clearNearby, exportJson, renderAll, events, etc.) ‚îÄ‚îÄ‚îÄ
    // Paste your existing functions here: tryReopen, getDrops, saveDrops, addDrop, clearNearby, exportJson, renderAll,
    // event listeners (dropBtn.onclick, clearBtn.onclick, exportJsonBtn.onclick, dropZone events, fileInput.onchange, reloadHistoryBtn.onclick, storage listener)

    // GPS with better feedback
    if (navigator.geolocation) {
      navigator.geolocation.watchPosition(
        pos => {
          userLat = pos.coords.latitude;
          userLng = pos.coords.longitude;
          updateLocInfo();
          renderAll();
          updateHistoryStats();
        },
        err => showStatus(`GPS error: ${err.message} ‚Äì try outdoors`, 'error'),
        { enableHighAccuracy: true, timeout: 30000, maximumAge: 0 }
      );
      setTimeout(() => {
        if (userLat === null) showStatus('GPS still waiting‚Ä¶ Move outside or toggle location', 'error');
      }, 60000);
    } else {
      showStatus('Geolocation not supported', 'error');
    }

    // Init
    updateLocInfo();
    renderAll();
    // setTimeout(tryReopen, 1000);  // Uncomment if you have tryReopen defined

    // Example minimal renderAll (expand with your full version)
    function renderAll() {
      const list = document.getElementById('pinList');
      if (!userLat) {
        list.innerHTML = '<p style="text-align:center;color:#555;padding:3rem 1rem;">Waiting for GPS‚Ä¶</p>';
        return;
      }
      const drops = getDrops ? getDrops().filter(d => coordsMatch(d.lat, d.lng, userLat, userLng)) : [];
      const hist  = timelinePoints.filter(p => coordsMatch(p.lat, p.lng, userLat, userLng));

      if (!drops.length && !hist.length) {
        list.innerHTML = '<p style="text-align:center;color:#555;padding:3rem 1rem;">No pins nearby yet</p>';
        return;
      }

      list.innerHTML = '';
      const groups = {};
      [...drops, ...hist].forEach(p => {
        const k = `${round(p.lat)},${round(p.lng)}`;
        groups[k] = groups[k] || [];
        groups[k].push(p);
      });

      Object.entries(groups).forEach(([k, items]) => {
        const [lat, lng] = k.split(',').map(Number);
        const group = document.createElement('div');
        group.className = 'location-group';
        group.innerHTML = `<div class="location-header">üìç ${lat.toFixed(6)}, ${lng.toFixed(6)} (${items.length})</div>`;
        items.sort((a,b) => new Date(b.timestamp) - new Date(a.timestamp)).forEach(p => {
          const pin = document.createElement('div');
          pin.className = `pin ${p.type}`;
          const isDrop = p.type === 'drop';
          pin.innerHTML = `
            <div class="pin-header">${isDrop ? p.name : 'Footprint'}</div>
            <div class="pin-msg">${isDrop ? p.msg : `‚âà${p.accuracy || '?'}m`}</div>
            <div class="pin-time">${new Date(p.timestamp).toLocaleString([], {dateStyle:'medium', timeStyle:'short'})}</div>
          `;
          group.appendChild(pin);
        });
        list.appendChild(group);
      });
    }

    // Add your other functions (getDrops, addDrop, etc.) below if missing
    function getDrops() { return []; } // Placeholder - replace with your localStorage code
    // ...
  </script>
</body>
</html>